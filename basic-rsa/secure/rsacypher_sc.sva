// @lang=sva @ts=8

module property_checker
  // Adjust this parameter before elaboration with
  // set_elaborate_option -golden -vhdl_generic {keysize=4}
  #(parameter KEYSIZE = 4)
  (
  input clk_i,
  input rst_i
  );

  default clocking default_clk @(posedge clk_i); endclocking

  `include "tidal.sv"

`begin_tda(ops)


  localparam [KEYSIZE-1:0] keysize_zero = '0; 

  function logic [KEYSIZE-1:0] modexp(input logic [KEYSIZE-1:0] b, input logic [KEYSIZE-1:0] e, input logic [KEYSIZE-1:0] m);
    logic [2*KEYSIZE-1:0] temp_res, square;

    square = {keysize_zero, b};
    temp_res = 1;

    for (int i = 0; i < KEYSIZE; i++) begin
      temp_res = e[i] ? (square * temp_res) % {keysize_zero, m} : temp_res;
      square = (square * square) % {keysize_zero, m};
    end

    return temp_res[KEYSIZE-1:0];
  endfunction


  sequence reset_sequence;
    (rst_i == 1'b1);
  endsequence


  sequence t_finish;
    await_o(t, 4, rsacypher_sc.done == 1'b1, 2 + KEYSIZE * (KEYSIZE + 1) + (KEYSIZE - 1) - 4);
  endsequence


  property reset_p;
    reset_sequence
    |=>
    t ##0 (rsacypher_sc.done   == 1'b1) and
    t ##0 (rsacypher_sc.multgo == 1'b0) and
    t ##0 (rsacypher_sc.sqrgo  == 1'b0) and
    t ##0 (rsacypher_sc.count  ==   '0) and
    t ##0 (rsacypher_sc.root   ==   '0) and
    t ##0 (rsacypher_sc.modreg ==   '0) and
    t ##0 (rsacypher_sc.tempin ==   '0) and
    t ##0 (rsacypher_sc.sqrin  ==   '0) and
    t ##0 (rsacypher_sc.cypher ==   '0) and

    t ##0 (rsacypher_sc.count_sc       ==   '0) and
    t ##0 (rsacypher_sc.data_label_q   == 1'b0) and
    t ##0 (rsacypher_sc.exp_label_q    == 1'b0) and
    t ##0 (rsacypher_sc.mod_label_q    == 1'b0) and
    t ##0 (rsacypher_sc.root_label_q   == 1'b0) and
    t ##0 (rsacypher_sc.sqrin_label_q  == 1'b0) and
    t ##0 (rsacypher_sc.tempin_label_q == 1'b0) and

    t ##0 (rsacypher_sc.modmultiply.first == 1'b1) and
    t ##0 (rsacypher_sc.modsqr.first      == 1'b1);
  endproperty
  reset_p_a: assert property (reset_p);


  property idle_p;
    t ##0 (rsacypher_sc.done == 1'b1) and
    t ##0 (rsacypher_sc.ds   == 1'b0)
  implies
    t ##1 (rsacypher_sc.done   == 1'b1) and
    t ##1 (rsacypher_sc.cypher == $past(rsacypher_sc.cypher));
  endproperty
  idle_p_a: assert property (disable iff (rst_i) idle_p);


  /*
   * Regular modular exponentiaiton if indata < inMod
   * This constraint is according to the specification (but does not influence the best or worst case latency)
   * The latency for KEYSIZE = 4 is as follows:
   *  - Best case: 4 clock cycles (0**1%8)
   *    1 cycle setup + 2 cycle modmult operation (mplier = 1) + 1 cycle output forwarding
   *  - Worst case: 25 clock cycles (9**9%12)
   *    1 cycle setup + 4 * 5 cycle modmult operations + 3 * 1 cycle overhead between operations + 1 cycle output forwarding
   *  In general: 
   *  - Best case: 4 clock cycles
   *  - Worst case: KEYSIZE**2 + 2 * KEYSIZE + 1
   */
  property modexp_p;
  logic [KEYSIZE-1:0] b, e, m;
    t ##0 (rsacypher_sc.done == 1'b1) and
    t ##0 (rsacypher_sc.ds   == 1'b1) and
    t ##0 (rsacypher_sc.indata < rsacypher_sc.inMod) and
    t ##0 (rsacypher_sc.indata > 0) || (rsacypher_sc.inExp > 0) and

    t ##0 set_freeze(b, rsacypher_sc.indata) and
    t ##0 set_freeze(e, rsacypher_sc.inExp ) and
    t ##0 set_freeze(m, rsacypher_sc.inMod )

  implies

    during_o(t, 1, t_finish, -1, (rsacypher_sc.done == 1'b0)) and
    t_finish ##0 (rsacypher_sc.done == 1'b1) and
    t_finish ##0 (rsacypher_sc.cypher == modexp(b, e, m));
  endproperty
  modexp_p_a: assert property (disable iff (rst_i) modexp_p);


`end_tda

endmodule

bind rsacypher_sc property_checker #(.KEYSIZE(KEYSIZE)) checker_bind(.clk_i(clk), .rst_i(reset));